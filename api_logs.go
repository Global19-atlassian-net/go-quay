/*
 * Quay Frontend
 *
 * This API allows you to perform many of the operations required to work with Quay repositories, users, and organizations. You can find out more at <a href=\"https://quay.io\">Quay</a>.
 *
 * API version: v1
 * Contact: support@quay.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package quay

import (
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"golang.org/x/net/context"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type LogsApiService service

/* LogsApiService
Gets the aggregated logs for the specified organization.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param orgname The name of the organization
@param optional (nil or map[string]interface{}) with one or more of:
    @param "performer" (string) Username for which to filter logs.
    @param "endtime" (string) Latest time to which to get logs. (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs. (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) GetAggregateOrgLogs(ctx context.Context, orgname string, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/organization/{orgname}/aggregatelogs"
	localVarPath = strings.Replace(localVarPath, "{"+"orgname"+"}", fmt.Sprintf("%v", orgname), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["performer"], "string", "performer"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["performer"].(string); localVarOk {
		localVarQueryParams.Add("performer", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}

/* LogsApiService
Returns the aggregated logs for the specified repository.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param repository The full path of the repository. e.g. namespace/name
@param optional (nil or map[string]interface{}) with one or more of:
    @param "endtime" (string) Latest time to which to get logs (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) GetAggregateRepoLogs(ctx context.Context, repository string, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/repository/{repository}/aggregatelogs"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", fmt.Sprintf("%v", repository), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}

/* LogsApiService
Returns the aggregated logs for the current user.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "performer" (string) Username for which to filter logs.
    @param "endtime" (string) Latest time to which to get logs. (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs. (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) GetAggregateUserLogs(ctx context.Context, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/user/aggregatelogs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["performer"], "string", "performer"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["performer"].(string); localVarOk {
		localVarQueryParams.Add("performer", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}

/* LogsApiService
List the logs for the specified organization.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param orgname The name of the organization
@param optional (nil or map[string]interface{}) with one or more of:
    @param "nextPage" (string) The page token for the next page
    @param "page" (int32) The page number for the logs
    @param "performer" (string) Username for which to filter logs.
    @param "endtime" (string) Latest time to which to get logs. (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs. (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) ListOrgLogs(ctx context.Context, orgname string, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/organization/{orgname}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"orgname"+"}", fmt.Sprintf("%v", orgname), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["nextPage"], "string", "nextPage"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["performer"], "string", "performer"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["nextPage"].(string); localVarOk {
		localVarQueryParams.Add("next_page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["performer"].(string); localVarOk {
		localVarQueryParams.Add("performer", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}

/* LogsApiService
List the logs for the specified repository.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param repository The full path of the repository. e.g. namespace/name
@param optional (nil or map[string]interface{}) with one or more of:
    @param "nextPage" (string) The page token for the next page
    @param "page" (int32) The page number for the logs
    @param "endtime" (string) Latest time to which to get logs (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) ListRepoLogs(ctx context.Context, repository string, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/repository/{repository}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"repository"+"}", fmt.Sprintf("%v", repository), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["nextPage"], "string", "nextPage"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["nextPage"].(string); localVarOk {
		localVarQueryParams.Add("next_page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}

/* LogsApiService
List the logs for the current user.
 * @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "nextPage" (string) The page token for the next page
    @param "performer" (string) Username for which to filter logs.
    @param "endtime" (string) Latest time to which to get logs. (%m/%d/%Y %Z)
    @param "starttime" (string) Earliest time from which to get logs. (%m/%d/%Y %Z)
@return */
func (a *LogsApiService) ListUserLogs(ctx context.Context, localVarOptionals map[string]interface{}) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/user/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if err := typeCheckParameter(localVarOptionals["nextPage"], "string", "nextPage"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["performer"], "string", "performer"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["endtime"], "string", "endtime"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["starttime"], "string", "starttime"); err != nil {
		return nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["nextPage"].(string); localVarOk {
		localVarQueryParams.Add("next_page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["performer"].(string); localVarOk {
		localVarQueryParams.Add("performer", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["endtime"].(string); localVarOk {
		localVarQueryParams.Add("endtime", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["starttime"].(string); localVarOk {
		localVarQueryParams.Add("starttime", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}
	return localVarHttpResponse, err
}
